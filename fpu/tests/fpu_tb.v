//==============================================================================
//      File:           $URL$
//      Version:        Automatically generated by 'System Verilog to VPI' script
//      Author:         Script By Tom Golubev
//      Copyright:      Copyright 2005-2009 UC Santa Cruz
//==============================================================================

//==============================================================================
//     Section:        License
//==============================================================================
//      Copyright (c) 2005-2009, Regents of the University of California
//      All rights reserved.
//
//      Redistribution and use in source and binary forms, with or without modification,
//      are permitted provided thatthefollowing conditions are met:
//
//              - Redistributions of source code must retain the above copyright notice,
//                      this list ofconditions and the following disclaimer.
//              - Redistributions in binary form must reproduce the above copyright
//                      notice, this list ofconditions and the following disclaimer
//                      in the documentation and/or other materials provided with the
//                      distribution.
//             - Neither the name of the University of California, Santa Cruz nor the
//                      names of its contributors may be used to endorse or promote
//                     products derived from this software without specific prior
//                      written permission.
//
//      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHTHOLDERSAND CONTRIBUTORS "AS IS" AND
//      ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//      WARRANTIES OF MERCHANTABILITY ANDFITNESS FOR A PARTICULAR PURPOSE ARE
//      DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//      ANY DIRECT, INDIRECT, INCIDENTAL,SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//      LOSS OF USE, DATA, ORPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//      ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//      (INCLUDING NEGLIGENCE OROTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//      SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//==============================================================================


/****************************************************************************
    Description: TestBench Verilog File for fpu.v
 
****************************************************************************/


`include "scoore_fpu.h"
import scoore_fpu::*;
import retry_common::*;

`ifdef USE_SDF
 `timescale 1ns / 1fs
 `include "asic/fpu_netlist.v"
// `define NTC 1
// `define RECREM 1
`endif

module  fpu_tb();

  //Start DUT variable definition

  reg                        start;
  
  reg [`FP_STATE_BITS-1:0]   state;
  RoundType                  round;
  reg [`OP_TYPE_BITS-1:0]    op;
  reg [`FP_TYPE_D_BITS-1:0]  src1;
  reg [`FP_TYPE_D_BITS-1:0]  src2;
 
  reg                        in_retry;


  wire [`FP_TYPE_D_BITS-1:0] fpu_result;
  wire [`FP_STATE_BITS-1:0]  fpu_state;
  wire                       fpu_ready;
  wire [3-1:0]               fpu_icc; 
 
  wire                       out_retry;

  logic mclk;
  logic                            clk;
  logic                            reset;

  //Retry Re-clocking signals
  //inputs
  ReclkIOType rci;
  ReclkIOType rco;

    fpu fpu_dut(.*);
  
  real                                  val;
  real                                  val_clk_delay;
  real                                  val_set_delay;
  real                                  val_check_delay;
  real                                  val_clk_width;
  int                                   tb_cycle;

  initial begin
    if (!$value$plusargs("clk=%g",val)) begin
      val                               = 100;
    end
    if (!$value$plusargs("clk_delay=%g",val_clk_delay)) begin
      val_clk_delay                     = 0.0/10;
    end
    if (!$value$plusargs("set_delay=%g",val_set_delay)) begin
      val_set_delay                     = 5.2/10;
    end
    if (!$value$plusargs("check_delay=%g",val_check_delay)) begin
      val_check_delay                     = 9.6/10;
    end
    if (!$value$plusargs("clk_width=%g",val_clk_width)) begin
      val_clk_width                      = 5.0/10;
    end

    $display("full clock %5.3f GHz +clk=%g +clk_delay=%.2f +clk_width=%.2f +set_delay=%.2f +check_delay=%.2f", 1.0/val, val, val_clk_delay, val_clk_width, val_set_delay, val_check_delay);
  end


`ifdef USE_SDF
  initial begin
    $sdf_annotate("asic/fpu.sdf", fpu_dut);
  end
`endif

  always @(posedge reset) begin
    $display("reset called");
  end

  initial begin
    reset                               = 1'b1;
    mclk                                = 1'b1;
    clk                                 = 1'b1;
    
    $fpu_init(reset);

`ifdef USE_SAIF

    //$read_rtl_saif("fpu_dump.saif","fpu_tb.fpu_dut");
    $set_gate_level_monitoring("rtl_on");
    $set_toggle_region("fpu_tb.fpu_dut");
    $toggle_start();

    $dumpfile("fpu_dump.vcd");
    $dumpvars();
    $dumpon;

    #(100000*val_clk_delay)
    #10
    $toggle_stop();
    #10$toggle_report("fpu_dump.saif", 1.0e-12, "fpu_tb.fpu_dut");
    //$dumpoff;
    $dumpflush;
    $display("Done with the SAIF/VCD sampling\n");
    $finish;
`endif
  end

  always begin
    #(val/2) mclk                   = ~mclk;
  end

`ifdef USE_SDF
  always @(posedge clk) begin // Sync with master clock
    #(val_clk_width*val) clk                   = 1'b0;
  end

  always @(posedge mclk) begin
    #(val_clk_delay*val) clk                   = 1'b1;
  end

`else
  always @(posedge clk) begin // Sync with master clock
    // Pulse width
    #(val/2) clk                   = 1'b0;
  end

  always @(posedge mclk) begin
    #(val) clk                   = 1'b1;
  end
`endif


`ifdef USE_SDF
  always @(posedge clk) begin
    #(val_set_delay*val)
    $fpu_set(clk, reset, start, state, round, op, src1, src2 , fpu_result, fpu_state, fpu_ready, in_retry, out_retry, rci.cmd, rci.clk);
  end
  
  always @(posedge clk) begin
    #(val_check_delay*val)
    $fpu_check(clk, reset, start, state, round, op, src1, src2 , fpu_result, fpu_state, fpu_ready, in_retry, out_retry, rci.cmd, rci.clk);
  end
`else
  always @(posedge clk) begin
    #(51*val/100) $fpu_set(clk, reset, start, state, round, op, src1, src2 , fpu_result, fpu_state, fpu_ready, in_retry, out_retry, rci.cmd, rci.clk);
    //$display("set at %d",$time);
    #(40*val/100) $fpu_check(clk, reset, start, state, round, op, src1, src2 , fpu_result, fpu_state, fpu_ready, in_retry, out_retry, rci.cmd, rci.clk);
    //$display("check at %d",$time);
  end
`endif

endmodule
 
